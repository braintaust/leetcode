class Solution:
    def numIslands(self, grid):
        db=len(grid)-1
        if (db<0):
            return 0
        lb=0
        rb=len(grid[0])-1
        ub=0
        if (rb<0):
            return 0
    #        x-1,y
    # x,y-1    x,y      x,y+1
    #        x+1,y
    # 方向数组，它表示了相对于当前位置的 4 个方向的横、纵坐标的偏移量，这是一个常见的技巧
    # directions = [(-1, 0), (0, -1), (1, 0), (0, 1)]
        ls = (0,-1)
        rs = (0,1)
        us = (-1,0)
        ds = (1,0)

        queue = [(0,0)]
        queue_with_1 = []
        his_step = set()
        his_step.add((0,0))
        count = 0
        # loc_1_set = set()
        while queue:
            # i, j =  queue.pop(0)  可以这么取元组的值
            k = queue.pop(0)
            if grid[k[0]][k[1]] == '1':
                queue_with_1.append(k)
                while queue_with_1:
                    #i, j =  queue_with_1.pop(0)  可以这么取元组的值
                    m = queue_with_1.pop(0) 
                    #可以对四个方向上做一个循环
                    #for direction in self.directions:
                    #    new_i = i + direction[0]
                    #    new_j = j + direction[1]
                    #    if 0 <= new_i < m and 0 <= new_j < n and not marked[new_i][new_j] and grid[new_i][new_j] == '1':
                    #
                    if m[1] + ls[1] >= lb and (m[0],m[1] + ls[1]) not in his_step:
                        if grid[m[0]][m[1] + ls[1]] == '1':
                            queue_with_1.append((m[0],m[1] + ls[1]))
                        else:
                            queue.append((m[0],m[1] + ls[1]))
                        his_step.add((m[0],m[1] + ls[1]))
                    if m[1] + rs[1] <= rb and (m[0],m[1] + rs[1]) not in his_step:
                        if grid[m[0]][m[1] + rs[1]] == '1':
                            queue_with_1.append((m[0],m[1] + rs[1]))
                        else:
                            queue.append((m[0],m[1] + rs[1]))
                        his_step.add((m[0],m[1] + rs[1]))
                    if m[0] + us[0] >= ub and (m[0] + us[0],m[1]) not in his_step:
                        if grid[m[0] + us[0]][m[1]] == '1':
                            queue_with_1.append((m[0] + us[0],m[1]))
                        else:
                            queue.append((m[0] + us[0],m[1]))
                        his_step.add((m[0] + us[0],m[1]))
                    if m[0] + ds[0] <= db and (m[0] + ds[0],m[1]) not in his_step:
                        if grid[m[0] + ds[0]][m[1]] == '1':
                            queue_with_1.append((m[0] + ds[0],m[1]))
                        else:
                            queue.append((m[0] + ds[0],m[1]))
                        his_step.add((m[0] + ds[0],m[1]))
                count += 1       
            else:
                #可以对四个方向上做一个循环
                if k[1] + ls[1] >= lb and (k[0],k[1] + ls[1]) not in his_step:
                    if grid[k[0]][k[1] + ls[1]] == '1':
                        queue.insert(0,(k[0],k[1] + ls[1]))
                        his_step.add((k[0],k[1] + ls[1]))
                        continue
                    else:
                        queue.append((k[0],k[1] + ls[1]))
                        his_step.add((k[0],k[1] + ls[1]))
                if k[1] + rs[1] <= rb and (k[0],k[1] + rs[1]) not in his_step:
                    if grid[k[0]][k[1] + rs[1]] == '1':
                        queue.insert(0,(k[0],k[1] + rs[1]))
                        his_step.add((k[0],k[1] + rs[1]))
                        continue
                    else:
                        queue.append((k[0],k[1] + rs[1]))
                        his_step.add((k[0],k[1] + rs[1]))
                if k[0] + us[0] >= ub and (k[0] + us[0],k[1]) not in his_step:
                    if grid[k[0] + us[0]][k[1]] == '1':
                        queue.insert(0,(k[0] + us[0],k[1]))
                        his_step.add((k[0] + us[0],k[1]))
                        continue
                    queue.append((k[0] + us[0],k[1]))
                    his_step.add((k[0] + us[0],k[1]))
                if k[0] + ds[0] <= db and (k[0] + ds[0],k[1]) not in his_step:
                    if grid[k[0] + ds[0]][k[1]] == '1':
                        queue.insert(0,(k[0] + ds[0],k[1]))
                        his_step.add((k[0] + ds[0],k[1]))
                        continue
                    queue.append((k[0] + ds[0],k[1]))
                    his_step.add((k[0] + ds[0],k[1]))
        return count

            
if __name__ == "__main__":
    # grid = [["1","1","1","0","0"],["1","1","0","1","0"],["1","0","0","0","0"],["0","1","0","0","1"]]
    # grid = [["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]]
    # grid = [[]]
    # grid = []
    # grid = [["1","0"]]

    #58个
    # grid = [["1","0","0","1","1","1","0","1","1","0","0","0","0","0","0","0","0","0","0","0"],
    #         ["1","0","0","1","1","0","0","1","0","0","0","1","0","1","0","1","0","0","1","0"],
    #         ["0","0","0","1","1","1","1","0","1","0","1","1","0","0","0","0","1","0","1","0"],
    #         ["0","0","0","1","1","0","0","1","0","0","0","1","1","1","0","0","1","0","0","1"],
    #         ["0","0","0","0","0","0","0","1","1","1","0","0","0","0","0","0","0","0","0","0"],
    #         ["1","0","0","0","0","1","0","1","0","1","1","0","0","0","0","0","0","1","0","1"],
    #         ["0","0","0","1","0","0","0","1","0","1","0","1","0","1","0","1","0","1","0","1"],
    #         ["0","0","0","1","0","1","0","0","1","1","0","1","0","1","1","0","1","1","1","0"],
    #         ["0","0","0","0","1","0","0","1","1","0","0","0","0","1","0","0","0","1","0","1"],
    #         ["0","0","1","0","0","1","0","0","0","0","0","1","0","0","1","0","0","0","1","0"],
    #         ["1","0","0","1","0","0","0","0","0","0","0","1","0","0","1","0","1","0","1","0"],
    #         ["0","1","0","0","0","1","0","1","0","1","1","0","1","1","1","0","1","1","0","0"],
    #         ["1","1","0","1","0","0","0","0","1","0","0","0","0","0","0","1","0","0","0","1"],
    #         ["0","1","0","0","1","1","1","0","0","0","1","1","1","1","1","0","1","0","0","0"],
    #         ["0","0","1","1","1","0","0","0","1","1","0","0","0","1","0","1","0","0","0","0"],
    #         ["1","0","0","1","0","1","0","0","0","0","1","0","0","0","1","0","1","0","1","1"],
    #         ["1","0","1","0","0","0","0","0","0","1","0","0","0","1","0","1","0","0","0","0"],
    #         ["0","1","1","0","0","0","1","1","1","0","1","0","1","0","1","1","1","1","0","0"],
    #         ["0","1","0","0","0","0","1","1","0","0","1","0","1","0","0","1","0","0","1","1"],
    #         ["0","0","0","0","0","0","1","1","1","1","0","1","0","0","0","1","1","0","0","0"]]
    grid = [["1","0","1"],
            ["0","1","0"],
            ["1","0","1"]]

    count = Solution().numIslands(grid)
    print(count)